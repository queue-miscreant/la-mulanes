; Adapted from program code for NES 101 (Michael Martin), 2001-2

.alias        sprite	$200

.alias        spriteBLy	$2000
.alias        spriteBLs	$2001
.alias        spriteBLd	$2002
.alias        spriteBLx	$2003

.alias        spriteBRy	$2004
.alias        spriteBRs	$2005
.alias        spriteBRd	$2006
.alias        spriteBRx	$2007

.alias        spriteULy	$2008
.alias        spriteULs	$2009
.alias        spriteULd	$200A
.alias        spriteULx	$200B

.alias        spriteURy	$200C
.alias        spriteURs	$200D
.alias        spriteURd	$200E
.alias        spriteURx	$200F

.alias        jump      $C8
.alias        ground    $D0
.alias		  maxjump	$40
.alias		  gravity 	$02

.alias	lemezaUL0		$00
.alias	lemezaUL1		$01
.alias	lemezaUR0		$02
.alias	lemezaUR1		$03
.alias	lemezaBLStatic	$04
.alias	lemezaBRStatic	$05
.alias	lemezaBL0		$06
.alias	lemezaBL1		$07
.alias	lemezaBR0		$08
.alias	lemezaBR1		$09

.alias	lemezaULjump	$0A
.alias	lemezaURjump	$0B
.alias	lemezaBLjump	$0C
.alias	lemezaBRjump	$0D

.alias	lemezaULfall	$0E
.alias	lemezaURfall	$0F
.alias	lemezaBLfall	$10
.alias	lemezaBRfall	$11

.segment zp
.org $0000

;$00: data 
.space freq 1
.space currbuttons 1
.space prevbuttons 1

;$03: button data
.space a 1	; debounce for a
.space b 1	; debounce for b
.space up 1 ; 
.space holdlr 1;

;$06: 
.space sx 1	;	subpixel horizontal positioning
.space dx 1 ;	horizontal movement
.space sy 1	;	subpixel vertical positioning
.space dy 1 ;	vertical movement
.space acc 1 ;	i know gravity ain't an excuse
.space jumplock 1

;$0C: constants and clocks
.space facing 1 ; bit 1: direction facing (0 = right, 1 = left), upper: animation count
.space subpx 1  ; constant 8

; If we had a normal data segment, it would have an .org $0300, so
; that it doesn't stomp on our sprite data.

; Actual program code.  We only have one PRG-ROM chip here, so the
; origin is $C000.
.text
.org $C000

reset:  sei
	cld
	; Wait two VBLANKs.
*	lda $2002
	bpl -
*	lda $2002
	bpl -

	; Clear out RAM.
        lda #$00
        ldx #$00
*       sta $000,x
        sta $100,x
        sta $200,x
        sta $300,x
        sta $400,x
        sta $500,x
        sta $600,x
        sta $700,x
        inx
        bne -

	; Reset the stack pointer.
        ldx #$FF
        txs

	; Disable all graphics.
        lda #$00
        sta $2000
        sta $2001

	jsr init'sprites
	jsr init'sound

        lda #%10001000
        sta $2000
        lda #%00011110
        sta $2001

	cli

	; Transfer control to the VBLANK routines.
loop:   jmp loop

init'sprites:
        ; Clear page #2, which we'll use to hold sprite data
        lda #$00
        ldx #$00
*       sta sprite, x
        inx
        bne -

        ; initialize Sprite 0
        lda #ground
        sta spriteBLy          ; Y coordinate
        sta spriteBRy
		sbc #8
        sta spriteULy
        sta spriteURy

        stx spriteBLx         ; X coordinate
        stx spriteULx
		lda #$08
        sta spriteBRx
        sta spriteURx

        lda #lemezaBLStatic
        sta spriteBLs         ; Pattern number
		lda #lemezaBRStatic
        sta spriteBRs         ; Pattern number
        lda #lemezaUL0
        sta spriteULs
        lda #lemezaUR0
        sta spriteURs

		lda #8
		sta subpx

load'palette:
        lda #$3F
        ldx #$00
        sta $2006
        stx $2006
*       lda palette,x
        sta $2007
        inx
        cpx #$20
        bne -
        rts

init'sound:
        ; initialize sound hardware
		; only turn on square wave 1
        lda #$05
        sta $4015
		; disable sweep
        lda #$00
        sta $4001
	; disable frame interrupt
	lda #$40
	sta $4017
        rts

do'input:
		ldx #0
		ldy #2
        lda #$01        ; strobe joypad
        sta $4016
        stx $4016

        lda $4016        ; A button
        and #1
        beq not'a
		eor a			 ; debounce with last known value
		beq do'b
		sta a

		jsr play'square
		stx dy
		stx dx
		lda #ground
		sta spriteBLy
		sta spriteBRy

		jmp do'b

not'a:	stx a
do'b:	lda $4016        ; B
		and #1
		beq not'b
		eor b			 ; debounce b
		beq do'up
		sta b

		jsr play'tri

		jmp do'up

not'b:	stx b 
do'up:	lda $4016        ; Select does nothing
        lda $4016        ; Start does nothing
        lda $4016        ; Up

        and #1			 ; only on press
        beq rel'up
		eor up
		beq do'down
		sta up

		lda acc
		bne do'down		 ; can't jump in midair
		lda #gravity
		sta acc
		lda #jump		 ; TODO I guess add feather in some higher memory?
		sta dy
		lda dx
		sta jumplock	 ; the last jump velocity
		jmp do'down

rel'up:	eor up
		beq not'up
		lda dy
		bpl not'up		; only when going up
		stx dy
not'up: stx up
do'down:
		lda $4016               ; down
        and #1
        beq do'le

do'le:	ldx #0
do'lr:	lda $4016				; load left or right
		and #1
		beq do'ri
		sta holdlr

		lda jumplock			; horizontal velocity at beginning of jump?
		bne jumping'le			; are we jumping and moving? then go to the jumping part
		lda dy					; okay, maybe we're jumping, but not moving
		bmi do'ri				; only able to change when falling
		beq lr'done				; we can only do the slow speed
		inx
		inx
		inx
		jmp lr'done
jumping'le:	
		inx
		lda #1
		bit facing				; holding left; if 0, then decelerate
		bne lr'jump
		inx
		jmp lr'jump

do'ri:	ldx #4
		dey
		bne do'lr
							; not left or right
		lda #lemezaBLStatic	; store the still sprites
		sta spriteBLs
		lda #lemezaBRStatic
		sta spriteBRs
		sty holdlr
		lda jumplock
		sta dx
		rts
lr'jump:
		lda jumping'data,x
		sta jumplock
		jmp update'done
lr'done:
		dey
		beq facing'right
		lda #$01
		ora facing
		jmp facing'done
facing'right:
		lda #$FE
		and facing
facing'done:
		sta facing
		lda jumping'data,x
update'done:
		sta dx

		lda #lemezaBL0
		sta spriteBLs
		lda #lemezaBR0
		sta spriteBRs
		rts

;subroutine called with the following:
;	X contains 0-255, pointing to data on the zero page
;	A contains the value you want to add in subpixels, which are 8 bits, 
;		with a fixed point at the fourth bit
;	returns (in A) offset to 'higher' bits (like those stored in a sprite)
subpixel'manage:		
		clc
		adc $00,X
		pha
		bpl lower'bits
		eor #$FF		; negate
		adc #1
lower'bits:
		and #$0F
		sta $00,X
		pla

		lsr				; arithmetic shift right
		lsr
		lsr
		lsr
		bit subpx
		beq not'neg
		clc
		adc	#$F0
not'neg:
		clc
		rts

update'sprite:
		clc
		lda facing		; use the upper bits for animation
		adc #2
		sta facing

		lda dx
		ldx #sx
		jsr subpixel'manage
		adc spriteBLx
		sta spriteULx
		adc #8
		sta spriteBRx
		sta spriteURx

		clc
		lda dy			; do some gravity
		adc acc
		bvc store'acc
		lda #maxjump	; maximum jump velocity
		clv
store'acc:
		sta dy
		ldx #sy
		jsr subpixel'manage
		adc spriteBLy
		pha
		sbc #ground
		bpl hit'ground
		pla
		jmp draw'sprite
hit'ground:
		pla
		ldx #0
		stx dy			; turn off the vertical movement
		stx sy
		stx acc
		stx jumplock	; free the lock
		ldy holdlr		; stopped holding left or right
		bne draw'sprite
		stx dx
		lda #ground
draw'sprite:
		sta spriteBLy
		sta spriteBRy
		sbc #8
		sta spriteURy
		sta spriteULy

		lda dy			; manipulate sprite if jumping/falling
		;and #$F8
		beq do'anim
		bpl falling'spr
		ldx #lemezaBLjump
		sta spriteBLs
		lda #lemezaBRjump
		sta spriteBRs
		lda #lemezaULjump
		sta spriteULs
		lda #lemezaURjump
		sta spriteURs
		jmp try'reflect

falling'spr:
		ldx #lemezaBLfall
		sta spriteBLs
		lda #lemezaBRfall
		sta spriteBRs
		lda #lemezaULfall
		sta spriteULs
		lda #lemezaURfall
		sta spriteURs
		jmp try'reflect

do'anim:
		lda dx			; only use animated if moving
		beq try'reflect
		lda jumplock
		bne try'reflect
		lda facing
		and #$10
		bne try'reflect

		inc spriteBLs
		inc spriteBRs
		inc spriteULs
		inc spriteURs

try'reflect:
		lda facing
		and #1
		bne	do'reflect	; no horizontal reflection

		lda spriteBLd
		and #$BF		; turn off the reflect bit
		sta spriteBLd
		sta spriteBRd
		sta spriteULd
		sta spriteURd

		jmp reflect'done
		
do'reflect:
		lda spriteBLs	; swap lower
		ldx spriteBRs
		stx spriteBLs
		sta spriteBRs

		lda spriteULs	; swap upper
		ldx spriteURs
		stx spriteULs
		sta spriteURs

		lda spriteBLd
		ora #$40		; turn on the reflect bit
		sta spriteBLd
		sta spriteBRd
		sta spriteULd
		sta spriteURd

reflect'done:
		lda dx
		bpl no'lag'compensate
		dec spriteURx	; lag compensation
		dec spriteBRx

no'lag'compensate:
        lda #>sprite
        sta $4014       ; Jam page $200-$2FF into SPR-RAM
		rts


play'square:
		lda #$84		 ; decaying envelope
		sta $4000
		lda freq		 ; period in here
		sta $4002
		lda #$09		 ; length and period high
		sta $4003
		rts

play'tri:
		lda freq
		sta $400A
		lda #$09
		sta $400B
		lda #$1F
		sta $4008
		rts

vblank:
		lda #lemezaUL0
		sta spriteULs
		lda #lemezaUR0
		sta spriteURs

		jsr update'sprite
		jsr do'input
		
irq:    rti

palette:
.byte $0E,$00,$0E,$19,$00,$00,$00,$00,$00,$00,$00,$00,$01,$00,$01,$21	; BG
.byte $0E,$0F,$1A,$38,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	; Sprite
jumping'data:
.byte $E8,$E0,$0C,$F4,$18,$F4,$20,$0C	; dx values for jumping and otherwise
										; used as lookup table in input subroutine
;.byte $E8,$E0,$F4,$F4,$18,$0C,$20,$0C	; this table is closer to the remake's jumping physics
;(normal value),(value when left is pressed during a jump),(value when right is pressed during a jump),(value when l/r during a neutral jump)

.advance $FFFA
.word vblank, reset, irq
