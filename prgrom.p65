; Adapted from program code for NES 101 (Michael Martin), 2001-2

.alias        sprite	$200
.alias        jump      $C8
.alias        ground    $D0
.alias		  maxjump	$40
.alias		  gravity 	$02

.segment zp
.org $0000

;$00: data 
.space freq 1
.space currbuttons 1
.space prevbuttons 1

;$03: button data
.space a 1	; debounce for a
.space b 1	; debounce for b
.space up 1 ; 
.space holdlr 1;

;$06: 
.space sx 1	;	subpixel horizontal positioning
.space dx 1 ;	horizontal movement
.space sy 1	;	subpixel vertical positioning
.space dy 1 ;	vertical movement
.space acc 1 ;	i know gravity ain't an excuse
.space jumplock 1

;$0C: constants and clocks
.space facing 1 ; bit 1: direction facing (0 = right, 1 = left), upper: animation count
.space subpx 1  ; constant 8

; If we had a normal data segment, it would have an .org $0300, so
; that it doesn't stomp on our sprite data.

; Actual program code.  We only have one PRG-ROM chip here, so the
; origin is $C000.
.text
.org $C000

reset:  sei
	cld
	; Wait two VBLANKs.
*	lda $2002
	bpl -
*	lda $2002
	bpl -

	; Clear out RAM.
        lda #$00
        ldx #$00
*       sta $000,x
        sta $100,x
        sta $200,x
        sta $300,x
        sta $400,x
        sta $500,x
        sta $600,x
        sta $700,x
        inx
        bne -

	; Reset the stack pointer.
        ldx #$FF
        txs

	; Disable all graphics.
        lda #$00
        sta $2000
        sta $2001

	jsr init'sprites
	jsr init'sound

        lda #%10101000
        sta $2000
        lda #%00011110
        sta $2001

	cli

	; Transfer control to the VBLANK routines.
loop:   jmp loop

init'sprites:
        ; Clear page #2, which we'll use to hold sprite data
        lda #$00
        ldx #$00
*       sta sprite, x
        inx
        bne -

        ; initialize Sprite 0
        lda #ground
        sta sprite          ; Y coordinate
        sta sprite+4        ; Y coordinate

        stx sprite+3        ; X coordinate
		lda #$08
        sta sprite+7        ; X coordinate
        lda #$02
        sta sprite+1        ; Pattern number
        lda #$06
        sta sprite+5        

		lda #8
		sta subpx

load'palette:
        lda #$3F
        ldx #$00
        sta $2006
        stx $2006
*       lda palette,x
        sta $2007
        inx
        cpx #$20
        bne -
        rts

init'sound:
        ; initialize sound hardware
		; only turn on square wave 1
        lda #$05
        sta $4015
		; disable sweep
        lda #$00
        sta $4001
	; disable frame interrupt
	lda #$40
	sta $4017
        rts

do'input:
		ldx #0
		ldy #2
        lda #$01        ; strobe joypad
        sta $4016
        stx $4016

        lda $4016        ; A button
        and #1
        beq not'a
		eor a			 ; debounce with last known value
		beq do'b
		sta a

		jsr play'square
		stx dy
		stx dx
		lda #ground
		sta sprite
		sta sprite+4

		jmp do'b

not'a:	stx a
do'b:	lda $4016        ; B
		and #1
		beq not'b
		eor b			 ; debounce b
		beq do'up
		sta b

		jsr play'tri

		jmp do'up

not'b:	stx b 
do'up:	lda $4016        ; Select does nothing
        lda $4016        ; Start does nothing
        lda $4016        ; Up

        and #1			 ; only on press
        beq rel'up
		eor up
		beq do'down
		sta up

		lda acc
		bne do'down		 ; can't jump in midair
		lda #gravity
		sta acc
		lda #jump		 ; TODO I guess add feather in some higher memory?
		sta dy
		lda dx
		sta jumplock	 ; the last jump velocity
		jmp do'down

rel'up:	eor up
		beq not'up
		lda dy
		bpl not'up		; only when going up
		stx dy
not'up: stx up
do'down:
		lda $4016               ; down
        and #1
        beq do'le

do'le:	ldx #0
do'lr:	lda $4016				; load left or right
		and #1
		beq do'ri
		sta holdlr

		lda jumplock			; horizontal velocity at beginning of jump?
		bne jumping'le			; are we jumping and moving? then go to the jumping part
		lda dy					; okay, maybe we're jumping, but not moving
		bmi do'ri				; only able to change when falling
		beq lr'done				; we can only do the slow speed
		inx
		inx
		inx
		jmp lr'done
jumping'le:	
		inx
		lda #1
		bit facing				; holding left; if 0, then decelerate
		bne lr'jump
		inx
		jmp lr'jump

do'ri:	ldx #4
		dey
		bne do'lr
							; not left or right
		lda #$0A			; store the still sprites
		sta sprite+1
		lda #$0C
		sta sprite+5
		sty holdlr
		lda jumplock
		sta dx
		rts
lr'jump:
		lda jumping'data,x
		sta jumplock
		jmp update'done
lr'done:
		dey
		beq facing'right
		lda #$01
		ora facing
		jmp facing'done
facing'right:
		lda #$FE
		and facing
facing'done:
		sta facing
		lda jumping'data,x
update'done:
		sta dx

		lda #$02
		sta sprite+1
		lda #$06
		sta sprite+5
		rts

;subroutine called with the following:
;	X contains 0-255, pointing to data on the zero page
;	A contains the value you want to add in subpixels, which are 8 bits, 
;		with a fixed point at the fourth bit
;	returns (in A) offset to 'higher' bits (like those stored in a sprite)
subpixel'manage:		
		clc
		adc $00,X
		pha
		bpl lower'bits
		eor #$FF		; negate
		adc #1
lower'bits:
		and #$0F
		sta $00,X
		pla

		lsr				; arithmetic shift right
		lsr
		lsr
		lsr
		bit subpx
		beq not'neg
		clc
		adc	#$F0
not'neg:
		clc
		rts

update'sprite:
		clc
		lda facing		; use the upper bits for animation
		adc #2
		sta facing

		lda dx
		ldx #sx
		jsr subpixel'manage
		adc sprite+3
		sta sprite+3
		adc #8
		sta sprite+7

		clc
		lda dy			; do some gravity
		adc acc
		bvc store'acc
		lda #maxjump	; maximum jump velocity
		clv
store'acc:
		sta dy
		ldx #sy
		jsr subpixel'manage
		adc sprite
		pha
		sbc #ground
		bpl hit'ground
		pla
		jmp draw'sprite
hit'ground:
		pla
		ldx #0
		stx dy			; turn off the vertical movement
		stx sy
		stx acc
		stx jumplock	; free the lock
		ldy holdlr		; stopped holding left or right
		bne draw'sprite
		stx dx
		lda #ground
draw'sprite:
		sta sprite
		sta sprite+4

		lda dy			; manipulate sprite if jumping/falling
		and #$F8
		beq do'anim
		bpl falling'spr
		lda #$0E
		sta sprite+1
		lda #$10
		sta sprite+5
		jmp try'reflect

falling'spr:
		lda #$12
		sta sprite+1
		lda #$14
		sta sprite+5
		jmp try'reflect

do'anim:
		lda dx			; only use animated if moving
		beq try'reflect
		lda jumplock
		bne try'reflect
		lda facing
		and #$10
		bne try'reflect

		inc sprite+1
		inc sprite+1
		inc sprite+5
		inc sprite+5

try'reflect:
		lda facing
		and #1
		bne	do'reflect	; no horizontal reflection

		lda sprite+2
		and #$BF		; turn off the reflect bit
		sta sprite+2
		sta sprite+6

		jmp reflect'done
		
do'reflect:
		lda sprite+1	; swap
		ldx sprite+5
		stx sprite+1
		sta sprite+5

		lda sprite+2
		ora #$40		; turn on the reflect bit
		sta sprite+2
		sta sprite+6

reflect'done:
		lda dx
		bpl no'lag'compensate
		dec sprite+7	; lag compensation
no'lag'compensate:
        lda #>sprite
        sta $4014       ; Jam page $200-$2FF into SPR-RAM
		rts


play'square:
		lda #$84		 ; decaying envelope
		sta $4000
		lda freq		 ; period in here
		sta $4002
		lda #$09		 ; length and period high
		sta $4003
		rts

play'tri:
		lda freq
		sta $400A
		lda #$09
		sta $400B
		lda #$1F
		sta $4008
		rts

vblank: jsr update'sprite
		jsr do'input
		
irq:    rti

palette:
.byte $0E,$00,$0E,$19,$00,$00,$00,$00,$00,$00,$00,$00,$01,$00,$01,$21	; BG
.byte $0E,$0F,$1A,$38,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	; Sprite
jumping'data:
.byte $E8,$E0,$0C,$F4,$18,$F4,$20,$0C	; dx values for jumping and otherwise
										; used as lookup table in input subroutine
;.byte $E8,$E0,$F4,$F4,$18,$0C,$20,$0C	; this table is closer to the remake's jumping physics
;(normal value),(value when left is pressed during a jump),(value when right is pressed during a jump),(value when l/r during a neutral jump)

.advance $FFFA
.word vblank, reset, irq
